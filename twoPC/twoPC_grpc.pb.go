// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.1
// source: twoPC/twoPC.proto

package twoPC

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TwoPC_NotifyLiveness_FullMethodName     = "/twoPC.twoPC/NotifyLiveness"
	TwoPC_NotifyByzantine_FullMethodName    = "/twoPC.twoPC/NotifyByzantine"
	TwoPC_RequestTransaction_FullMethodName = "/twoPC.twoPC/RequestTransaction"
	TwoPC_RequestBalance_FullMethodName     = "/twoPC.twoPC/RequestBalance"
	TwoPC_RequestDS_FullMethodName          = "/twoPC.twoPC/RequestDS"
	TwoPC_ProcessPrePrepare_FullMethodName  = "/twoPC.twoPC/ProcessPrePrepare"
	TwoPC_ProcessPrepare_FullMethodName     = "/twoPC.twoPC/ProcessPrepare"
	TwoPC_ProcessCommit_FullMethodName      = "/twoPC.twoPC/ProcessCommit"
	TwoPC_ReplyToClient_FullMethodName      = "/twoPC.twoPC/ReplyToClient"
	TwoPC_CoordinatorPrepare_FullMethodName = "/twoPC.twoPC/CoordinatorPrepare"
	TwoPC_ParticipantPrepare_FullMethodName = "/twoPC.twoPC/ParticipantPrepare"
	TwoPC_CoordinatorCommit_FullMethodName  = "/twoPC.twoPC/CoordinatorCommit"
	TwoPC_ParticipantCommit_FullMethodName  = "/twoPC.twoPC/ParticipantCommit"
	TwoPC_CoordinatorAck_FullMethodName     = "/twoPC.twoPC/CoordinatorAck"
)

// TwoPCClient is the client API for TwoPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TwoPCClient interface {
	// Client to server
	NotifyLiveness(ctx context.Context, in *Liveness, opts ...grpc.CallOption) (*Empty, error)
	NotifyByzantine(ctx context.Context, in *Byzantine, opts ...grpc.CallOption) (*Empty, error)
	RequestTransaction(ctx context.Context, in *TxRequest, opts ...grpc.CallOption) (*Empty, error)
	RequestBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error)
	RequestDS(ctx context.Context, in *ServerRequested, opts ...grpc.CallOption) (*DSResponse, error)
	// Server to server
	ProcessPrePrepare(ctx context.Context, in *PrePrepare, opts ...grpc.CallOption) (*Prepare, error)
	ProcessPrepare(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Commit, error)
	ProcessCommit(ctx context.Context, in *Commit, opts ...grpc.CallOption) (*Empty, error)
	// Server to client
	ReplyToClient(ctx context.Context, in *Reply, opts ...grpc.CallOption) (*Empty, error)
	// TwoPC
	CoordinatorPrepare(ctx context.Context, in *TxRequest, opts ...grpc.CallOption) (*Empty, error)
	ParticipantPrepare(ctx context.Context, in *TwoPCPrepare, opts ...grpc.CallOption) (*Empty, error)
	CoordinatorCommit(ctx context.Context, in *TwoPCPrepare, opts ...grpc.CallOption) (*Empty, error)
	ParticipantCommit(ctx context.Context, in *TwoPCCommit, opts ...grpc.CallOption) (*Empty, error)
	CoordinatorAck(ctx context.Context, in *Ack, opts ...grpc.CallOption) (*Empty, error)
}

type twoPCClient struct {
	cc grpc.ClientConnInterface
}

func NewTwoPCClient(cc grpc.ClientConnInterface) TwoPCClient {
	return &twoPCClient{cc}
}

func (c *twoPCClient) NotifyLiveness(ctx context.Context, in *Liveness, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_NotifyLiveness_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) NotifyByzantine(ctx context.Context, in *Byzantine, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_NotifyByzantine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) RequestTransaction(ctx context.Context, in *TxRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_RequestTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) RequestBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BalanceResponse)
	err := c.cc.Invoke(ctx, TwoPC_RequestBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) RequestDS(ctx context.Context, in *ServerRequested, opts ...grpc.CallOption) (*DSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DSResponse)
	err := c.cc.Invoke(ctx, TwoPC_RequestDS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) ProcessPrePrepare(ctx context.Context, in *PrePrepare, opts ...grpc.CallOption) (*Prepare, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prepare)
	err := c.cc.Invoke(ctx, TwoPC_ProcessPrePrepare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) ProcessPrepare(ctx context.Context, in *Prepare, opts ...grpc.CallOption) (*Commit, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Commit)
	err := c.cc.Invoke(ctx, TwoPC_ProcessPrepare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) ProcessCommit(ctx context.Context, in *Commit, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_ProcessCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) ReplyToClient(ctx context.Context, in *Reply, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_ReplyToClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) CoordinatorPrepare(ctx context.Context, in *TxRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_CoordinatorPrepare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) ParticipantPrepare(ctx context.Context, in *TwoPCPrepare, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_ParticipantPrepare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) CoordinatorCommit(ctx context.Context, in *TwoPCPrepare, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_CoordinatorCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) ParticipantCommit(ctx context.Context, in *TwoPCCommit, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_ParticipantCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPCClient) CoordinatorAck(ctx context.Context, in *Ack, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, TwoPC_CoordinatorAck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TwoPCServer is the server API for TwoPC service.
// All implementations must embed UnimplementedTwoPCServer
// for forward compatibility.
type TwoPCServer interface {
	// Client to server
	NotifyLiveness(context.Context, *Liveness) (*Empty, error)
	NotifyByzantine(context.Context, *Byzantine) (*Empty, error)
	RequestTransaction(context.Context, *TxRequest) (*Empty, error)
	RequestBalance(context.Context, *BalanceRequest) (*BalanceResponse, error)
	RequestDS(context.Context, *ServerRequested) (*DSResponse, error)
	// Server to server
	ProcessPrePrepare(context.Context, *PrePrepare) (*Prepare, error)
	ProcessPrepare(context.Context, *Prepare) (*Commit, error)
	ProcessCommit(context.Context, *Commit) (*Empty, error)
	// Server to client
	ReplyToClient(context.Context, *Reply) (*Empty, error)
	// TwoPC
	CoordinatorPrepare(context.Context, *TxRequest) (*Empty, error)
	ParticipantPrepare(context.Context, *TwoPCPrepare) (*Empty, error)
	CoordinatorCommit(context.Context, *TwoPCPrepare) (*Empty, error)
	ParticipantCommit(context.Context, *TwoPCCommit) (*Empty, error)
	CoordinatorAck(context.Context, *Ack) (*Empty, error)
	mustEmbedUnimplementedTwoPCServer()
}

// UnimplementedTwoPCServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTwoPCServer struct{}

func (UnimplementedTwoPCServer) NotifyLiveness(context.Context, *Liveness) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyLiveness not implemented")
}
func (UnimplementedTwoPCServer) NotifyByzantine(context.Context, *Byzantine) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyByzantine not implemented")
}
func (UnimplementedTwoPCServer) RequestTransaction(context.Context, *TxRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestTransaction not implemented")
}
func (UnimplementedTwoPCServer) RequestBalance(context.Context, *BalanceRequest) (*BalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestBalance not implemented")
}
func (UnimplementedTwoPCServer) RequestDS(context.Context, *ServerRequested) (*DSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestDS not implemented")
}
func (UnimplementedTwoPCServer) ProcessPrePrepare(context.Context, *PrePrepare) (*Prepare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessPrePrepare not implemented")
}
func (UnimplementedTwoPCServer) ProcessPrepare(context.Context, *Prepare) (*Commit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessPrepare not implemented")
}
func (UnimplementedTwoPCServer) ProcessCommit(context.Context, *Commit) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessCommit not implemented")
}
func (UnimplementedTwoPCServer) ReplyToClient(context.Context, *Reply) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplyToClient not implemented")
}
func (UnimplementedTwoPCServer) CoordinatorPrepare(context.Context, *TxRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoordinatorPrepare not implemented")
}
func (UnimplementedTwoPCServer) ParticipantPrepare(context.Context, *TwoPCPrepare) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantPrepare not implemented")
}
func (UnimplementedTwoPCServer) CoordinatorCommit(context.Context, *TwoPCPrepare) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoordinatorCommit not implemented")
}
func (UnimplementedTwoPCServer) ParticipantCommit(context.Context, *TwoPCCommit) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParticipantCommit not implemented")
}
func (UnimplementedTwoPCServer) CoordinatorAck(context.Context, *Ack) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoordinatorAck not implemented")
}
func (UnimplementedTwoPCServer) mustEmbedUnimplementedTwoPCServer() {}
func (UnimplementedTwoPCServer) testEmbeddedByValue()               {}

// UnsafeTwoPCServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TwoPCServer will
// result in compilation errors.
type UnsafeTwoPCServer interface {
	mustEmbedUnimplementedTwoPCServer()
}

func RegisterTwoPCServer(s grpc.ServiceRegistrar, srv TwoPCServer) {
	// If the following call pancis, it indicates UnimplementedTwoPCServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TwoPC_ServiceDesc, srv)
}

func _TwoPC_NotifyLiveness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Liveness)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).NotifyLiveness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_NotifyLiveness_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).NotifyLiveness(ctx, req.(*Liveness))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_NotifyByzantine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Byzantine)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).NotifyByzantine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_NotifyByzantine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).NotifyByzantine(ctx, req.(*Byzantine))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_RequestTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).RequestTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_RequestTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).RequestTransaction(ctx, req.(*TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_RequestBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).RequestBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_RequestBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).RequestBalance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_RequestDS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerRequested)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).RequestDS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_RequestDS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).RequestDS(ctx, req.(*ServerRequested))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_ProcessPrePrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrePrepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).ProcessPrePrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_ProcessPrePrepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).ProcessPrePrepare(ctx, req.(*PrePrepare))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_ProcessPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Prepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).ProcessPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_ProcessPrepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).ProcessPrepare(ctx, req.(*Prepare))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_ProcessCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Commit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).ProcessCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_ProcessCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).ProcessCommit(ctx, req.(*Commit))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_ReplyToClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reply)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).ReplyToClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_ReplyToClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).ReplyToClient(ctx, req.(*Reply))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_CoordinatorPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).CoordinatorPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_CoordinatorPrepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).CoordinatorPrepare(ctx, req.(*TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_ParticipantPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoPCPrepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).ParticipantPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_ParticipantPrepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).ParticipantPrepare(ctx, req.(*TwoPCPrepare))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_CoordinatorCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoPCPrepare)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).CoordinatorCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_CoordinatorCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).CoordinatorCommit(ctx, req.(*TwoPCPrepare))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_ParticipantCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoPCCommit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).ParticipantCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_ParticipantCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).ParticipantCommit(ctx, req.(*TwoPCCommit))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPC_CoordinatorAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPCServer).CoordinatorAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPC_CoordinatorAck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPCServer).CoordinatorAck(ctx, req.(*Ack))
	}
	return interceptor(ctx, in, info, handler)
}

// TwoPC_ServiceDesc is the grpc.ServiceDesc for TwoPC service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TwoPC_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "twoPC.twoPC",
	HandlerType: (*TwoPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NotifyLiveness",
			Handler:    _TwoPC_NotifyLiveness_Handler,
		},
		{
			MethodName: "NotifyByzantine",
			Handler:    _TwoPC_NotifyByzantine_Handler,
		},
		{
			MethodName: "RequestTransaction",
			Handler:    _TwoPC_RequestTransaction_Handler,
		},
		{
			MethodName: "RequestBalance",
			Handler:    _TwoPC_RequestBalance_Handler,
		},
		{
			MethodName: "RequestDS",
			Handler:    _TwoPC_RequestDS_Handler,
		},
		{
			MethodName: "ProcessPrePrepare",
			Handler:    _TwoPC_ProcessPrePrepare_Handler,
		},
		{
			MethodName: "ProcessPrepare",
			Handler:    _TwoPC_ProcessPrepare_Handler,
		},
		{
			MethodName: "ProcessCommit",
			Handler:    _TwoPC_ProcessCommit_Handler,
		},
		{
			MethodName: "ReplyToClient",
			Handler:    _TwoPC_ReplyToClient_Handler,
		},
		{
			MethodName: "CoordinatorPrepare",
			Handler:    _TwoPC_CoordinatorPrepare_Handler,
		},
		{
			MethodName: "ParticipantPrepare",
			Handler:    _TwoPC_ParticipantPrepare_Handler,
		},
		{
			MethodName: "CoordinatorCommit",
			Handler:    _TwoPC_CoordinatorCommit_Handler,
		},
		{
			MethodName: "ParticipantCommit",
			Handler:    _TwoPC_ParticipantCommit_Handler,
		},
		{
			MethodName: "CoordinatorAck",
			Handler:    _TwoPC_CoordinatorAck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "twoPC/twoPC.proto",
}
